#line 1 "numpy/core/src/umath/loops.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- c -*- */

#define _UMATHMODULE

#include "Python.h"

#include "npy_config.h"
#ifdef  ENABLE_SEPARATE_COMPILATION
#define PY_ARRAY_UNIQUE_SYMBOL _npy_umathmodule_ARRAY_API
#define NO_IMPORT_ARRAY
#endif

#include "numpy/noprefix.h"
#include "numpy/ufuncobject.h"
#include "numpy/npy_math.h"
#include "numpy/halffloat.h"

#include "numpy/npy_3kcompat.h"

#include "ufunc_object.h"


/*
 *****************************************************************************
 **                             UFUNC LOOPS                                 **
 *****************************************************************************
 */

#define IS_BINARY_REDUCE ((args[0] == args[2])\
        && (steps[0] == steps[2])\
        && (steps[0] == 0))

#define OUTPUT_LOOP\
    char *op1 = args[1];\
    intp os1 = steps[1];\
    intp n = dimensions[0];\
    intp i;\
    for(i = 0; i < n; i++, op1 += os1)

#define UNARY_LOOP\
    char *ip1 = args[0], *op1 = args[1];\
    intp is1 = steps[0], os1 = steps[1];\
    intp n = dimensions[0];\
    intp i;\
    for(i = 0; i < n; i++, ip1 += is1, op1 += os1)

#define UNARY_LOOP_TWO_OUT\
    char *ip1 = args[0], *op1 = args[1], *op2 = args[2];\
    intp is1 = steps[0], os1 = steps[1], os2 = steps[2];\
    intp n = dimensions[0];\
    intp i;\
    for(i = 0; i < n; i++, ip1 += is1, op1 += os1, op2 += os2)

#define BINARY_LOOP\
    char *ip1 = args[0], *ip2 = args[1], *op1 = args[2];\
    intp is1 = steps[0], is2 = steps[1], os1 = steps[2];\
    intp n = dimensions[0];\
    intp i;\
    for(i = 0; i < n; i++, ip1 += is1, ip2 += is2, op1 += os1)

#define BINARY_REDUCE_LOOP_INNER\
    char *ip2 = args[1]; \
    intp is2 = steps[1]; \
    intp n = dimensions[0]; \
    intp i; \
    for(i = 0; i < n; i++, ip2 += is2)

#define BINARY_REDUCE_LOOP(TYPE)\
    char *iop1 = args[0]; \
    TYPE io1 = *(TYPE *)iop1; \
    BINARY_REDUCE_LOOP_INNER

#define BINARY_LOOP_TWO_OUT\
    char *ip1 = args[0], *ip2 = args[1], *op1 = args[2], *op2 = args[3];\
    intp is1 = steps[0], is2 = steps[1], os1 = steps[2], os2 = steps[3];\
    intp n = dimensions[0];\
    intp i;\
    for(i = 0; i < n; i++, ip1 += is1, ip2 += is2, op1 += os1, op2 += os2)

/******************************************************************************
 **                          GENERIC FLOAT LOOPS                             **
 *****************************************************************************/


typedef float halfUnaryFunc(npy_half x);
typedef float floatUnaryFunc(float x);
typedef double doubleUnaryFunc(double x);
typedef longdouble longdoubleUnaryFunc(longdouble x);
typedef npy_half halfBinaryFunc(npy_half x, npy_half y);
typedef float floatBinaryFunc(float x, float y);
typedef double doubleBinaryFunc(double x, double y);
typedef longdouble longdoubleBinaryFunc(longdouble x, longdouble y);


/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_e_e(char **args, intp *dimensions, intp *steps, void *func)
{
    halfUnaryFunc *f = (halfUnaryFunc *)func;
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *(npy_half *)op1 = f(in1);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_e_e_As_f_f(char **args, intp *dimensions, intp *steps, void *func)
{
    floatUnaryFunc *f = (floatUnaryFunc *)func;
    UNARY_LOOP {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        *(npy_half *)op1 = npy_float_to_half(f(in1));
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_e_e_As_d_d(char **args, intp *dimensions, intp *steps, void *func)
{
    doubleUnaryFunc *f = (doubleUnaryFunc *)func;
    UNARY_LOOP {
        const double in1 = npy_half_to_double(*(npy_half *)ip1);
        *(npy_half *)op1 = npy_double_to_half(f(in1));
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_f_f(char **args, intp *dimensions, intp *steps, void *func)
{
    floatUnaryFunc *f = (floatUnaryFunc *)func;
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *(float *)op1 = f(in1);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_f_f_As_d_d(char **args, intp *dimensions, intp *steps, void *func)
{
    doubleUnaryFunc *f = (doubleUnaryFunc *)func;
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *(float *)op1 = (float)f((double)in1);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_ee_e(char **args, intp *dimensions, intp *steps, void *func)
{
    halfBinaryFunc *f = (halfBinaryFunc *)func;
    BINARY_LOOP {
        npy_half in1 = *(npy_half *)ip1;
        npy_half in2 = *(npy_half *)ip2;
        *(npy_half *)op1 = f(in1, in2);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_ee_e_As_ff_f(char **args, intp *dimensions, intp *steps, void *func)
{
    floatBinaryFunc *f = (floatBinaryFunc *)func;
    BINARY_LOOP {
        float in1 = npy_half_to_float(*(npy_half *)ip1);
        float in2 = npy_half_to_float(*(npy_half *)ip2);
        *(npy_half *)op1 = npy_float_to_half(f(in1, in2));
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_ee_e_As_dd_d(char **args, intp *dimensions, intp *steps, void *func)
{
    doubleBinaryFunc *f = (doubleBinaryFunc *)func;
    BINARY_LOOP {
        double in1 = npy_half_to_double(*(npy_half *)ip1);
        double in2 = npy_half_to_double(*(npy_half *)ip2);
        *(npy_half *)op1 = npy_double_to_half(f(in1, in2));
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_ff_f(char **args, intp *dimensions, intp *steps, void *func)
{
    floatBinaryFunc *f = (floatBinaryFunc *)func;
    BINARY_LOOP {
        float in1 = *(float *)ip1;
        float in2 = *(float *)ip2;
        *(float *)op1 = f(in1, in2);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_ff_f_As_dd_d(char **args, intp *dimensions, intp *steps, void *func)
{
    doubleBinaryFunc *f = (doubleBinaryFunc *)func;
    BINARY_LOOP {
        float in1 = *(float *)ip1;
        float in2 = *(float *)ip2;
        *(float *)op1 = (double)f((double)in1, (double)in2);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_d_d(char **args, intp *dimensions, intp *steps, void *func)
{
    doubleUnaryFunc *f = (doubleUnaryFunc *)func;
    UNARY_LOOP {
        double in1 = *(double *)ip1;
        *(double *)op1 = f(in1);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_dd_d(char **args, intp *dimensions, intp *steps, void *func)
{
    doubleBinaryFunc *f = (doubleBinaryFunc *)func;
    BINARY_LOOP {
        double in1 = *(double *)ip1;
        double in2 = *(double *)ip2;
        *(double *)op1 = f(in1, in2);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_g_g(char **args, intp *dimensions, intp *steps, void *func)
{
    longdoubleUnaryFunc *f = (longdoubleUnaryFunc *)func;
    UNARY_LOOP {
        longdouble in1 = *(longdouble *)ip1;
        *(longdouble *)op1 = f(in1);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_gg_g(char **args, intp *dimensions, intp *steps, void *func)
{
    longdoubleBinaryFunc *f = (longdoubleBinaryFunc *)func;
    BINARY_LOOP {
        longdouble in1 = *(longdouble *)ip1;
        longdouble in2 = *(longdouble *)ip2;
        *(longdouble *)op1 = f(in1, in2);
    }
}



/******************************************************************************
 **                          GENERIC COMPLEX LOOPS                           **
 *****************************************************************************/


typedef void cdoubleUnaryFunc(cdouble *x, cdouble *r);
typedef void cfloatUnaryFunc(cfloat *x, cfloat *r);
typedef void clongdoubleUnaryFunc(clongdouble *x, clongdouble *r);
typedef void cdoubleBinaryFunc(cdouble *x, cdouble *y, cdouble *r);
typedef void cfloatBinaryFunc(cfloat *x, cfloat *y, cfloat *r);
typedef void clongdoubleBinaryFunc(clongdouble *x, clongdouble *y,
                                   clongdouble *r);

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_F_F(char **args, intp *dimensions, intp *steps, void *func)
{
    cfloatUnaryFunc *f = (cfloatUnaryFunc *)func;
    UNARY_LOOP {
        cfloat in1 = *(cfloat *)ip1;
        cfloat *out = (cfloat *)op1;
        f(&in1, out);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_F_F_As_D_D(char **args, intp *dimensions, intp *steps, void *func)
{
    cdoubleUnaryFunc *f = (cdoubleUnaryFunc *)func;
    UNARY_LOOP {
        cdouble tmp, out;
        tmp.real = (double)((float *)ip1)[0];
        tmp.imag = (double)((float *)ip1)[1];
        f(&tmp, &out);
        ((float *)op1)[0] = (float)out.real;
        ((float *)op1)[1] = (float)out.imag;
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_FF_F(char **args, intp *dimensions, intp *steps, void *func)
{
    cfloatBinaryFunc *f = (cfloatBinaryFunc *)func;
    BINARY_LOOP {
        cfloat in1 = *(cfloat *)ip1;
        cfloat in2 = *(cfloat *)ip2;
        cfloat *out = (cfloat *)op1;
        f(&in1, &in2, out);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_FF_F_As_DD_D(char **args, intp *dimensions, intp *steps, void *func)
{
    cdoubleBinaryFunc *f = (cdoubleBinaryFunc *)func;
    BINARY_LOOP {
        cdouble tmp1, tmp2, out;
        tmp1.real = (double)((float *)ip1)[0];
        tmp1.imag = (double)((float *)ip1)[1];
        tmp2.real = (double)((float *)ip2)[0];
        tmp2.imag = (double)((float *)ip2)[1];
        f(&tmp1, &tmp2, &out);
        ((float *)op1)[0] = (float)out.real;
        ((float *)op1)[1] = (float)out.imag;
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_D_D(char **args, intp *dimensions, intp *steps, void *func)
{
    cdoubleUnaryFunc *f = (cdoubleUnaryFunc *)func;
    UNARY_LOOP {
        cdouble in1 = *(cdouble *)ip1;
        cdouble *out = (cdouble *)op1;
        f(&in1, out);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_DD_D(char **args, intp *dimensions, intp *steps, void *func)
{
    cdoubleBinaryFunc *f = (cdoubleBinaryFunc *)func;
    BINARY_LOOP {
        cdouble in1 = *(cdouble *)ip1;
        cdouble in2 = *(cdouble *)ip2;
        cdouble *out = (cdouble *)op1;
        f(&in1, &in2, out);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_G_G(char **args, intp *dimensions, intp *steps, void *func)
{
    clongdoubleUnaryFunc *f = (clongdoubleUnaryFunc *)func;
    UNARY_LOOP {
        clongdouble in1 = *(clongdouble *)ip1;
        clongdouble *out = (clongdouble *)op1;
        f(&in1, out);
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_GG_G(char **args, intp *dimensions, intp *steps, void *func)
{
    clongdoubleBinaryFunc *f = (clongdoubleBinaryFunc *)func;
    BINARY_LOOP {
        clongdouble in1 = *(clongdouble *)ip1;
        clongdouble in2 = *(clongdouble *)ip2;
        clongdouble *out = (clongdouble *)op1;
        f(&in1, &in2, out);
    }
}


/******************************************************************************
 **                         GENERIC OBJECT lOOPS                             **
 *****************************************************************************/

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_O_O(char **args, intp *dimensions, intp *steps, void *func)
{
    unaryfunc f = (unaryfunc)func;
    UNARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject **out = (PyObject **)op1;
        PyObject *ret = f(in1 ? in1 : Py_None);
        if (ret == NULL) {
            return;
        }
        Py_XDECREF(*out);
        *out = ret;
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_O_O_method(char **args, intp *dimensions, intp *steps, void *func)
{
    char *meth = (char *)func;
    UNARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject **out = (PyObject **)op1;
        PyObject *ret = PyObject_CallMethod(in1 ? in1 : Py_None, meth, NULL);
        if (ret == NULL) {
            return;
        }
        Py_XDECREF(*out);
        *out = ret;
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_OO_O(char **args, intp *dimensions, intp *steps, void *func)
{
    binaryfunc f = (binaryfunc)func;
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        PyObject **out = (PyObject **)op1;
        PyObject *ret = f(in1 ? in1 : Py_None, in2 ? in2 : Py_None);
        if (ret == NULL) {
            return;
        }
        Py_XDECREF(*out);
        *out = ret;
    }
}

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_OO_O_method(char **args, intp *dimensions, intp *steps, void *func)
{
    char *meth = (char *)func;
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        PyObject **out = (PyObject **)op1;
        PyObject *ret = PyObject_CallMethod(in1 ? in1 : Py_None,
                                            meth, "(O)", in2);
        if (ret == NULL) {
            return;
        }
        Py_XDECREF(*out);
        *out = ret;
    }
}

/*
 * A general-purpose ufunc that deals with general-purpose Python callable.
 * func is a structure with nin, nout, and a Python callable function
 */

/*UFUNC_API*/
NPY_NO_EXPORT void
PyUFunc_On_Om(char **args, intp *dimensions, intp *steps, void *func)
{
    intp n =  dimensions[0];
    PyUFunc_PyFuncData *data = (PyUFunc_PyFuncData *)func;
    int nin = data->nin;
    int nout = data->nout;
    PyObject *tocall = data->callable;
    char *ptrs[NPY_MAXARGS];
    PyObject *arglist, *result;
    PyObject *in, **op;
    intp i, j, ntot;

    ntot = nin+nout;

    for(j = 0; j < ntot; j++) {
        ptrs[j] = args[j];
    }
    for(i = 0; i < n; i++) {
        arglist = PyTuple_New(nin);
        if (arglist == NULL) {
            return;
        }
        for(j = 0; j < nin; j++) {
            in = *((PyObject **)ptrs[j]);
            if (in == NULL) {
                in = Py_None;
            }
            PyTuple_SET_ITEM(arglist, j, in);
            Py_INCREF(in);
        }
        result = PyEval_CallObject(tocall, arglist);
        Py_DECREF(arglist);
        if (result == NULL) {
            return;
        }
        if (PyTuple_Check(result)) {
            if (nout != PyTuple_Size(result)) {
                Py_DECREF(result);
                return;
            }
            for(j = 0; j < nout; j++) {
                op = (PyObject **)ptrs[j+nin];
                Py_XDECREF(*op);
                *op = PyTuple_GET_ITEM(result, j);
                Py_INCREF(*op);
            }
            Py_DECREF(result);
        }
        else {
            op = (PyObject **)ptrs[nin];
            Py_XDECREF(*op);
            *op = result;
        }
        for(j = 0; j < ntot; j++) {
            ptrs[j] += steps[j];
        }
    }
}

/*
 *****************************************************************************
 **                             BOOLEAN LOOPS                               **
 *****************************************************************************
 */

#line 530

NPY_NO_EXPORT void
BOOL_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1)= in1 == in2;
    }
}

#line 530

NPY_NO_EXPORT void
BOOL_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1)= in1 != in2;
    }
}

#line 530

NPY_NO_EXPORT void
BOOL_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1)= in1 > in2;
    }
}

#line 530

NPY_NO_EXPORT void
BOOL_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1)= in1 >= in2;
    }
}

#line 530

NPY_NO_EXPORT void
BOOL_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1)= in1 < in2;
    }
}

#line 530

NPY_NO_EXPORT void
BOOL_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1)= in1 <= in2;
    }
}



#line 548

NPY_NO_EXPORT void
BOOL_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(Bool) {
            const Bool in2 = *(Bool *)ip2;
            io1 = io1 && in2;
            if (io1 == 0) {
                break;
            }
        }
        *((Bool *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const Bool in1 = *(Bool *)ip1;
            const Bool in2 = *(Bool *)ip2;
            *((Bool *)op1) = in1 && in2;
        }
    }
}

#line 548

NPY_NO_EXPORT void
BOOL_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(Bool) {
            const Bool in2 = *(Bool *)ip2;
            io1 = io1 || in2;
            if (io1 != 0) {
                break;
            }
        }
        *((Bool *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const Bool in1 = *(Bool *)ip1;
            const Bool in2 = *(Bool *)ip2;
            *((Bool *)op1) = in1 || in2;
        }
    }
}



NPY_NO_EXPORT void
BOOL_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 587
NPY_NO_EXPORT void
BOOL_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1) = (in1 > in2) ? in1 : in2;
    }
}

#line 587
NPY_NO_EXPORT void
BOOL_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        Bool in1 = *((Bool *)ip1) != 0;
        Bool in2 = *((Bool *)ip2) != 0;
        *((Bool *)op1) = (in1 < in2) ? in1 : in2;
    }
}


#line 602
NPY_NO_EXPORT void
BOOL_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        Bool in1 = *(Bool *)ip1;
        *((Bool *)op1) = in1 != 0;
    }
}

#line 602
NPY_NO_EXPORT void
BOOL_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        Bool in1 = *(Bool *)ip1;
        *((Bool *)op1) = in1 == 0;
    }
}


NPY_NO_EXPORT void
BOOL_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((Bool *)op1) = 1;
    }
}


/*
 *****************************************************************************
 **                           INTEGER LOOPS
 *****************************************************************************
 */

#line 632

#line 638

#define BYTE_floor_divide BYTE_divide
#define BYTE_fmax BYTE_maximum
#define BYTE_fmin BYTE_minimum

NPY_NO_EXPORT void
BYTE_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((byte *)op1) = 1;
    }
}

NPY_NO_EXPORT void
BYTE_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((byte *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
BYTE_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((byte *)op1) = (byte)(1.0/in1);
    }
}

NPY_NO_EXPORT void
BYTE_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((byte *)op1) = in1;
    }
}

NPY_NO_EXPORT void
BYTE_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((byte *)op1) = (byte)(-(byte)in1);
    }
}

NPY_NO_EXPORT void
BYTE_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
BYTE_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((byte *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 += *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 -= *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 *= *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 &= *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 |= *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 ^= *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 <<= *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
BYTE_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            io1 >>= *(byte *)ip2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
BYTE_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
BYTE_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
BYTE_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
BYTE_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
BYTE_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
BYTE_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
BYTE_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
BYTE_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
BYTE_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
BYTE_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            const byte in2 = *(byte *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
BYTE_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(byte) {
            const byte in2 = *(byte *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((byte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const byte in1 = *(byte *)ip1;
            const byte in2 = *(byte *)ip2;
            *((byte *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
BYTE_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(byte *)ip1);
        const double in2 = (double)(*(byte *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
BYTE_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = (float)*(byte *)ip1;
        const float in2 = (float)*(byte *)ip2;
        *((byte *)op1) = (byte) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
BYTE_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((byte *)op1) = 0;
        }
        else {
            *((byte *)op1)= in1 % in2;
        }

    }
}


#line 638

#define UBYTE_floor_divide UBYTE_divide
#define UBYTE_fmax UBYTE_maximum
#define UBYTE_fmin UBYTE_minimum

NPY_NO_EXPORT void
UBYTE_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((ubyte *)op1) = 1;
    }
}

NPY_NO_EXPORT void
UBYTE_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((ubyte *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
UBYTE_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((ubyte *)op1) = (ubyte)(1.0/in1);
    }
}

NPY_NO_EXPORT void
UBYTE_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((ubyte *)op1) = in1;
    }
}

NPY_NO_EXPORT void
UBYTE_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((ubyte *)op1) = (ubyte)(-(byte)in1);
    }
}

NPY_NO_EXPORT void
UBYTE_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
UBYTE_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((ubyte *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 += *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 -= *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 *= *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 &= *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 |= *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 ^= *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 <<= *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UBYTE_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            io1 >>= *(ubyte *)ip2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
UBYTE_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
UBYTE_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
UBYTE_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
UBYTE_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
UBYTE_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
UBYTE_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
UBYTE_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
UBYTE_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
UBYTE_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
UBYTE_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            const ubyte in2 = *(byte *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
UBYTE_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ubyte) {
            const ubyte in2 = *(byte *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((ubyte *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ubyte in1 = *(ubyte *)ip1;
            const ubyte in2 = *(ubyte *)ip2;
            *((ubyte *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
UBYTE_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(ubyte *)ip1);
        const double in2 = (double)(*(ubyte *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
UBYTE_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = (float)*(ubyte *)ip1;
        const float in2 = (float)*(ubyte *)ip2;
        *((ubyte *)op1) = (ubyte) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
UBYTE_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ubyte *)op1) = 0;
        }
        else {
            *((ubyte *)op1)= in1 % in2;
        }

    }
}



NPY_NO_EXPORT void
UBYTE_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((ubyte *)op1) = in1;
    }
}

NPY_NO_EXPORT void
BYTE_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((byte *)op1) = (in1 >= 0) ? in1 : -in1;
    }
}

NPY_NO_EXPORT void
UBYTE_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        *((ubyte *)op1) = in1 > 0 ? 1 : 0;
    }
}

NPY_NO_EXPORT void
BYTE_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const byte in1 = *(byte *)ip1;
        *((byte *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : 0);
    }
}

NPY_NO_EXPORT void
BYTE_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        /*
         * FIXME: On x86 at least, dividing the smallest representable integer
         * by -1 causes a SIFGPE (division overflow). We treat this case here
         * (to avoid a SIGFPE crash at python level), but a good solution would
         * be to treat integer division problems separately from FPU exceptions
         * (i.e. a different approach than npy_set_floatstatus_divbyzero()).
         */
        if (in2 == 0 || (in1 == NPY_MIN_BYTE && in2 == -1)) {
            npy_set_floatstatus_divbyzero();
            *((byte *)op1) = 0;
        }
        else if (((in1 > 0) != (in2 > 0)) && (in1 % in2 != 0)) {
            *((byte *)op1) = in1/in2 - 1;
        }
        else {
            *((byte *)op1) = in1/in2;
        }
    }
}

NPY_NO_EXPORT void
UBYTE_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ubyte *)op1) = 0;
        }
        else {
            *((ubyte *)op1)= in1/in2;
        }
    }
}

NPY_NO_EXPORT void
BYTE_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const byte in1 = *(byte *)ip1;
        const byte in2 = *(byte *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((byte *)op1) = 0;
        }
        else {
            /* handle mixed case the way Python does */
            const byte rem = in1 % in2;
            if ((in1 > 0) == (in2 > 0) || rem == 0) {
                *((byte *)op1) = rem;
            }
            else {
                *((byte *)op1) = rem + in2;
            }
        }
    }
}

NPY_NO_EXPORT void
UBYTE_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ubyte in1 = *(ubyte *)ip1;
        const ubyte in2 = *(ubyte *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((byte *)op1) = 0;
        }
        else {
            *((byte *)op1) = in1 % in2;
        }
    }
}


#line 632

#line 638

#define SHORT_floor_divide SHORT_divide
#define SHORT_fmax SHORT_maximum
#define SHORT_fmin SHORT_minimum

NPY_NO_EXPORT void
SHORT_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((short *)op1) = 1;
    }
}

NPY_NO_EXPORT void
SHORT_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((short *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
SHORT_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((short *)op1) = (short)(1.0/in1);
    }
}

NPY_NO_EXPORT void
SHORT_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((short *)op1) = in1;
    }
}

NPY_NO_EXPORT void
SHORT_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((short *)op1) = (short)(-(short)in1);
    }
}

NPY_NO_EXPORT void
SHORT_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
SHORT_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((short *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 += *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 -= *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 *= *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 &= *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 |= *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 ^= *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 <<= *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
SHORT_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            io1 >>= *(short *)ip2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
SHORT_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
SHORT_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
SHORT_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
SHORT_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
SHORT_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
SHORT_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
SHORT_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
SHORT_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
SHORT_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
SHORT_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            const short in2 = *(short *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
SHORT_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(short) {
            const short in2 = *(short *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((short *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const short in1 = *(short *)ip1;
            const short in2 = *(short *)ip2;
            *((short *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
SHORT_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(short *)ip1);
        const double in2 = (double)(*(short *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
SHORT_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = (float)*(short *)ip1;
        const float in2 = (float)*(short *)ip2;
        *((short *)op1) = (short) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
SHORT_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((short *)op1) = 0;
        }
        else {
            *((short *)op1)= in1 % in2;
        }

    }
}


#line 638

#define USHORT_floor_divide USHORT_divide
#define USHORT_fmax USHORT_maximum
#define USHORT_fmin USHORT_minimum

NPY_NO_EXPORT void
USHORT_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((ushort *)op1) = 1;
    }
}

NPY_NO_EXPORT void
USHORT_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((ushort *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
USHORT_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((ushort *)op1) = (ushort)(1.0/in1);
    }
}

NPY_NO_EXPORT void
USHORT_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((ushort *)op1) = in1;
    }
}

NPY_NO_EXPORT void
USHORT_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((ushort *)op1) = (ushort)(-(short)in1);
    }
}

NPY_NO_EXPORT void
USHORT_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
USHORT_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((ushort *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 += *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 -= *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 *= *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 &= *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 |= *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 ^= *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 <<= *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
USHORT_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            io1 >>= *(ushort *)ip2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
USHORT_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
USHORT_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
USHORT_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
USHORT_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
USHORT_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
USHORT_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
USHORT_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
USHORT_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
USHORT_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
USHORT_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            const ushort in2 = *(short *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
USHORT_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ushort) {
            const ushort in2 = *(short *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((ushort *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ushort in1 = *(ushort *)ip1;
            const ushort in2 = *(ushort *)ip2;
            *((ushort *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
USHORT_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(ushort *)ip1);
        const double in2 = (double)(*(ushort *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
USHORT_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = (float)*(ushort *)ip1;
        const float in2 = (float)*(ushort *)ip2;
        *((ushort *)op1) = (ushort) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
USHORT_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ushort *)op1) = 0;
        }
        else {
            *((ushort *)op1)= in1 % in2;
        }

    }
}



NPY_NO_EXPORT void
USHORT_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((ushort *)op1) = in1;
    }
}

NPY_NO_EXPORT void
SHORT_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((short *)op1) = (in1 >= 0) ? in1 : -in1;
    }
}

NPY_NO_EXPORT void
USHORT_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        *((ushort *)op1) = in1 > 0 ? 1 : 0;
    }
}

NPY_NO_EXPORT void
SHORT_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const short in1 = *(short *)ip1;
        *((short *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : 0);
    }
}

NPY_NO_EXPORT void
SHORT_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        /*
         * FIXME: On x86 at least, dividing the smallest representable integer
         * by -1 causes a SIFGPE (division overflow). We treat this case here
         * (to avoid a SIGFPE crash at python level), but a good solution would
         * be to treat integer division problems separately from FPU exceptions
         * (i.e. a different approach than npy_set_floatstatus_divbyzero()).
         */
        if (in2 == 0 || (in1 == NPY_MIN_SHORT && in2 == -1)) {
            npy_set_floatstatus_divbyzero();
            *((short *)op1) = 0;
        }
        else if (((in1 > 0) != (in2 > 0)) && (in1 % in2 != 0)) {
            *((short *)op1) = in1/in2 - 1;
        }
        else {
            *((short *)op1) = in1/in2;
        }
    }
}

NPY_NO_EXPORT void
USHORT_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ushort *)op1) = 0;
        }
        else {
            *((ushort *)op1)= in1/in2;
        }
    }
}

NPY_NO_EXPORT void
SHORT_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const short in1 = *(short *)ip1;
        const short in2 = *(short *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((short *)op1) = 0;
        }
        else {
            /* handle mixed case the way Python does */
            const short rem = in1 % in2;
            if ((in1 > 0) == (in2 > 0) || rem == 0) {
                *((short *)op1) = rem;
            }
            else {
                *((short *)op1) = rem + in2;
            }
        }
    }
}

NPY_NO_EXPORT void
USHORT_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ushort in1 = *(ushort *)ip1;
        const ushort in2 = *(ushort *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((short *)op1) = 0;
        }
        else {
            *((short *)op1) = in1 % in2;
        }
    }
}


#line 632

#line 638

#define INT_floor_divide INT_divide
#define INT_fmax INT_maximum
#define INT_fmin INT_minimum

NPY_NO_EXPORT void
INT_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((int *)op1) = 1;
    }
}

NPY_NO_EXPORT void
INT_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((int *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
INT_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((int *)op1) = (int)(1.0/in1);
    }
}

NPY_NO_EXPORT void
INT_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((int *)op1) = in1;
    }
}

NPY_NO_EXPORT void
INT_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((int *)op1) = (int)(-(int)in1);
    }
}

NPY_NO_EXPORT void
INT_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
INT_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((int *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
INT_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 += *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
INT_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 -= *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
INT_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 *= *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
INT_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 &= *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
INT_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 |= *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
INT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 ^= *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
INT_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 <<= *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
INT_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            io1 >>= *(int *)ip2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
INT_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
INT_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
INT_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
INT_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
INT_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
INT_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
INT_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
INT_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
INT_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
INT_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            const int in2 = *(int *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
INT_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(int) {
            const int in2 = *(int *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((int *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const int in1 = *(int *)ip1;
            const int in2 = *(int *)ip2;
            *((int *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
INT_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(int *)ip1);
        const double in2 = (double)(*(int *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
INT_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)*(int *)ip1;
        const double in2 = (double)*(int *)ip2;
        *((int *)op1) = (int) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
INT_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((int *)op1) = 0;
        }
        else {
            *((int *)op1)= in1 % in2;
        }

    }
}


#line 638

#define UINT_floor_divide UINT_divide
#define UINT_fmax UINT_maximum
#define UINT_fmin UINT_minimum

NPY_NO_EXPORT void
UINT_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((uint *)op1) = 1;
    }
}

NPY_NO_EXPORT void
UINT_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((uint *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
UINT_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((uint *)op1) = (uint)(1.0/in1);
    }
}

NPY_NO_EXPORT void
UINT_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((uint *)op1) = in1;
    }
}

NPY_NO_EXPORT void
UINT_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((uint *)op1) = (uint)(-(int)in1);
    }
}

NPY_NO_EXPORT void
UINT_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
UINT_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((uint *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
UINT_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 += *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UINT_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 -= *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UINT_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 *= *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UINT_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 &= *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UINT_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 |= *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UINT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 ^= *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UINT_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 <<= *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
UINT_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            io1 >>= *(uint *)ip2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
UINT_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
UINT_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
UINT_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
UINT_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
UINT_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
UINT_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
UINT_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
UINT_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
UINT_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
UINT_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            const uint in2 = *(int *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
UINT_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(uint) {
            const uint in2 = *(int *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((uint *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const uint in1 = *(uint *)ip1;
            const uint in2 = *(uint *)ip2;
            *((uint *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
UINT_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(uint *)ip1);
        const double in2 = (double)(*(uint *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
UINT_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)*(uint *)ip1;
        const double in2 = (double)*(uint *)ip2;
        *((uint *)op1) = (uint) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
UINT_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((uint *)op1) = 0;
        }
        else {
            *((uint *)op1)= in1 % in2;
        }

    }
}



NPY_NO_EXPORT void
UINT_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((uint *)op1) = in1;
    }
}

NPY_NO_EXPORT void
INT_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((int *)op1) = (in1 >= 0) ? in1 : -in1;
    }
}

NPY_NO_EXPORT void
UINT_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const uint in1 = *(uint *)ip1;
        *((uint *)op1) = in1 > 0 ? 1 : 0;
    }
}

NPY_NO_EXPORT void
INT_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const int in1 = *(int *)ip1;
        *((int *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : 0);
    }
}

NPY_NO_EXPORT void
INT_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        /*
         * FIXME: On x86 at least, dividing the smallest representable integer
         * by -1 causes a SIFGPE (division overflow). We treat this case here
         * (to avoid a SIGFPE crash at python level), but a good solution would
         * be to treat integer division problems separately from FPU exceptions
         * (i.e. a different approach than npy_set_floatstatus_divbyzero()).
         */
        if (in2 == 0 || (in1 == NPY_MIN_INT && in2 == -1)) {
            npy_set_floatstatus_divbyzero();
            *((int *)op1) = 0;
        }
        else if (((in1 > 0) != (in2 > 0)) && (in1 % in2 != 0)) {
            *((int *)op1) = in1/in2 - 1;
        }
        else {
            *((int *)op1) = in1/in2;
        }
    }
}

NPY_NO_EXPORT void
UINT_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((uint *)op1) = 0;
        }
        else {
            *((uint *)op1)= in1/in2;
        }
    }
}

NPY_NO_EXPORT void
INT_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = *(int *)ip1;
        const int in2 = *(int *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((int *)op1) = 0;
        }
        else {
            /* handle mixed case the way Python does */
            const int rem = in1 % in2;
            if ((in1 > 0) == (in2 > 0) || rem == 0) {
                *((int *)op1) = rem;
            }
            else {
                *((int *)op1) = rem + in2;
            }
        }
    }
}

NPY_NO_EXPORT void
UINT_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const uint in1 = *(uint *)ip1;
        const uint in2 = *(uint *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((int *)op1) = 0;
        }
        else {
            *((int *)op1) = in1 % in2;
        }
    }
}


#line 632

#line 638

#define LONG_floor_divide LONG_divide
#define LONG_fmax LONG_maximum
#define LONG_fmin LONG_minimum

NPY_NO_EXPORT void
LONG_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((long *)op1) = 1;
    }
}

NPY_NO_EXPORT void
LONG_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((long *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
LONG_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((long *)op1) = (long)(1.0/in1);
    }
}

NPY_NO_EXPORT void
LONG_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((long *)op1) = in1;
    }
}

NPY_NO_EXPORT void
LONG_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((long *)op1) = (long)(-(long)in1);
    }
}

NPY_NO_EXPORT void
LONG_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
LONG_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((long *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
LONG_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 += *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONG_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 -= *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONG_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 *= *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 &= *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 |= *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 ^= *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONG_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 <<= *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONG_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            io1 >>= *(long *)ip2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
LONG_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONG_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONG_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONG_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONG_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONG_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONG_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONG_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
LONG_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
LONG_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            const long in2 = *(long *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
LONG_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(long) {
            const long in2 = *(long *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((long *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const long in1 = *(long *)ip1;
            const long in2 = *(long *)ip2;
            *((long *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
LONG_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(long *)ip1);
        const double in2 = (double)(*(long *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
LONG_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)*(long *)ip1;
        const double in2 = (double)*(long *)ip2;
        *((long *)op1) = (long) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
LONG_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((long *)op1) = 0;
        }
        else {
            *((long *)op1)= in1 % in2;
        }

    }
}


#line 638

#define ULONG_floor_divide ULONG_divide
#define ULONG_fmax ULONG_maximum
#define ULONG_fmin ULONG_minimum

NPY_NO_EXPORT void
ULONG_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((ulong *)op1) = 1;
    }
}

NPY_NO_EXPORT void
ULONG_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((ulong *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
ULONG_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((ulong *)op1) = (ulong)(1.0/in1);
    }
}

NPY_NO_EXPORT void
ULONG_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((ulong *)op1) = in1;
    }
}

NPY_NO_EXPORT void
ULONG_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((ulong *)op1) = (ulong)(-(long)in1);
    }
}

NPY_NO_EXPORT void
ULONG_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
ULONG_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((ulong *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 += *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 -= *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 *= *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 &= *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 |= *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 ^= *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 <<= *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONG_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            io1 >>= *(ulong *)ip2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
ULONG_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONG_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONG_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONG_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONG_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONG_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONG_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONG_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
ULONG_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
ULONG_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            const ulong in2 = *(long *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
ULONG_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulong) {
            const ulong in2 = *(long *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((ulong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulong in1 = *(ulong *)ip1;
            const ulong in2 = *(ulong *)ip2;
            *((ulong *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
ULONG_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(ulong *)ip1);
        const double in2 = (double)(*(ulong *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
ULONG_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)*(ulong *)ip1;
        const double in2 = (double)*(ulong *)ip2;
        *((ulong *)op1) = (ulong) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
ULONG_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ulong *)op1) = 0;
        }
        else {
            *((ulong *)op1)= in1 % in2;
        }

    }
}



NPY_NO_EXPORT void
ULONG_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((ulong *)op1) = in1;
    }
}

NPY_NO_EXPORT void
LONG_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((long *)op1) = (in1 >= 0) ? in1 : -in1;
    }
}

NPY_NO_EXPORT void
ULONG_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        *((ulong *)op1) = in1 > 0 ? 1 : 0;
    }
}

NPY_NO_EXPORT void
LONG_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const long in1 = *(long *)ip1;
        *((long *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : 0);
    }
}

NPY_NO_EXPORT void
LONG_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        /*
         * FIXME: On x86 at least, dividing the smallest representable integer
         * by -1 causes a SIFGPE (division overflow). We treat this case here
         * (to avoid a SIGFPE crash at python level), but a good solution would
         * be to treat integer division problems separately from FPU exceptions
         * (i.e. a different approach than npy_set_floatstatus_divbyzero()).
         */
        if (in2 == 0 || (in1 == NPY_MIN_LONG && in2 == -1)) {
            npy_set_floatstatus_divbyzero();
            *((long *)op1) = 0;
        }
        else if (((in1 > 0) != (in2 > 0)) && (in1 % in2 != 0)) {
            *((long *)op1) = in1/in2 - 1;
        }
        else {
            *((long *)op1) = in1/in2;
        }
    }
}

NPY_NO_EXPORT void
ULONG_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ulong *)op1) = 0;
        }
        else {
            *((ulong *)op1)= in1/in2;
        }
    }
}

NPY_NO_EXPORT void
LONG_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const long in1 = *(long *)ip1;
        const long in2 = *(long *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((long *)op1) = 0;
        }
        else {
            /* handle mixed case the way Python does */
            const long rem = in1 % in2;
            if ((in1 > 0) == (in2 > 0) || rem == 0) {
                *((long *)op1) = rem;
            }
            else {
                *((long *)op1) = rem + in2;
            }
        }
    }
}

NPY_NO_EXPORT void
ULONG_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulong in1 = *(ulong *)ip1;
        const ulong in2 = *(ulong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((long *)op1) = 0;
        }
        else {
            *((long *)op1) = in1 % in2;
        }
    }
}


#line 632

#line 638

#define LONGLONG_floor_divide LONGLONG_divide
#define LONGLONG_fmax LONGLONG_maximum
#define LONGLONG_fmin LONGLONG_minimum

NPY_NO_EXPORT void
LONGLONG_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((longlong *)op1) = 1;
    }
}

NPY_NO_EXPORT void
LONGLONG_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((longlong *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
LONGLONG_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((longlong *)op1) = (longlong)(1.0/in1);
    }
}

NPY_NO_EXPORT void
LONGLONG_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((longlong *)op1) = in1;
    }
}

NPY_NO_EXPORT void
LONGLONG_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((longlong *)op1) = (longlong)(-(longlong)in1);
    }
}

NPY_NO_EXPORT void
LONGLONG_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
LONGLONG_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((longlong *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 += *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 -= *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 *= *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 &= *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 |= *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 ^= *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 <<= *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
LONGLONG_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            io1 >>= *(longlong *)ip2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
LONGLONG_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONGLONG_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONGLONG_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONGLONG_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONGLONG_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONGLONG_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONGLONG_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
LONGLONG_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
LONGLONG_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
LONGLONG_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            const longlong in2 = *(longlong *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
LONGLONG_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longlong) {
            const longlong in2 = *(longlong *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((longlong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longlong in1 = *(longlong *)ip1;
            const longlong in2 = *(longlong *)ip2;
            *((longlong *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
LONGLONG_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(longlong *)ip1);
        const double in2 = (double)(*(longlong *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
LONGLONG_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)*(longlong *)ip1;
        const double in2 = (double)*(longlong *)ip2;
        *((longlong *)op1) = (longlong) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
LONGLONG_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((longlong *)op1) = 0;
        }
        else {
            *((longlong *)op1)= in1 % in2;
        }

    }
}


#line 638

#define ULONGLONG_floor_divide ULONGLONG_divide
#define ULONGLONG_fmax ULONGLONG_maximum
#define ULONGLONG_fmin ULONGLONG_minimum

NPY_NO_EXPORT void
ULONGLONG_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((ulonglong *)op1) = 1;
    }
}

NPY_NO_EXPORT void
ULONGLONG_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((ulonglong *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
ULONGLONG_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((ulonglong *)op1) = (ulonglong)(1.0/in1);
    }
}

NPY_NO_EXPORT void
ULONGLONG_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((ulonglong *)op1) = in1;
    }
}

NPY_NO_EXPORT void
ULONGLONG_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((ulonglong *)op1) = (ulonglong)(-(longlong)in1);
    }
}

NPY_NO_EXPORT void
ULONGLONG_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((Bool *)op1) = !in1;
    }
}

NPY_NO_EXPORT void
ULONGLONG_invert(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((ulonglong *)op1) = ~in1;
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 += *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 + in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 -= *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 - in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 *= *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 * in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 &= *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 & in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 |= *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 | in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 ^= *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 ^ in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_left_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 <<= *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 << in2;
        }
    }
}

#line 711
NPY_NO_EXPORT void
ULONGLONG_right_shift(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            io1 >>= *(ulonglong *)ip2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = in1 >> in2;
        }
    }
}


#line 735
NPY_NO_EXPORT void
ULONGLONG_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONGLONG_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONGLONG_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONGLONG_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONGLONG_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONGLONG_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONGLONG_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 735
NPY_NO_EXPORT void
ULONGLONG_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
ULONGLONG_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 760
NPY_NO_EXPORT void
ULONGLONG_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            const ulonglong in2 = *(longlong *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = (in1 > in2) ? in1 : in2;
        }
    }
}

#line 760
NPY_NO_EXPORT void
ULONGLONG_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(ulonglong) {
            const ulonglong in2 = *(longlong *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((ulonglong *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const ulonglong in1 = *(ulonglong *)ip1;
            const ulonglong in2 = *(ulonglong *)ip2;
            *((ulonglong *)op1) = (in1 < in2) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
ULONGLONG_true_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)(*(ulonglong *)ip1);
        const double in2 = (double)(*(ulonglong *)ip2);
        *((double *)op1) = in1/in2;
    }
}

NPY_NO_EXPORT void
ULONGLONG_power(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = (double)*(ulonglong *)ip1;
        const double in2 = (double)*(ulonglong *)ip2;
        *((ulonglong *)op1) = (ulonglong) pow(in1, in2);
    }
}

NPY_NO_EXPORT void
ULONGLONG_fmod(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ulonglong *)op1) = 0;
        }
        else {
            *((ulonglong *)op1)= in1 % in2;
        }

    }
}



NPY_NO_EXPORT void
ULONGLONG_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((ulonglong *)op1) = in1;
    }
}

NPY_NO_EXPORT void
LONGLONG_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((longlong *)op1) = (in1 >= 0) ? in1 : -in1;
    }
}

NPY_NO_EXPORT void
ULONGLONG_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        *((ulonglong *)op1) = in1 > 0 ? 1 : 0;
    }
}

NPY_NO_EXPORT void
LONGLONG_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        *((longlong *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : 0);
    }
}

NPY_NO_EXPORT void
LONGLONG_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        /*
         * FIXME: On x86 at least, dividing the smallest representable integer
         * by -1 causes a SIFGPE (division overflow). We treat this case here
         * (to avoid a SIGFPE crash at python level), but a good solution would
         * be to treat integer division problems separately from FPU exceptions
         * (i.e. a different approach than npy_set_floatstatus_divbyzero()).
         */
        if (in2 == 0 || (in1 == NPY_MIN_LONGLONG && in2 == -1)) {
            npy_set_floatstatus_divbyzero();
            *((longlong *)op1) = 0;
        }
        else if (((in1 > 0) != (in2 > 0)) && (in1 % in2 != 0)) {
            *((longlong *)op1) = in1/in2 - 1;
        }
        else {
            *((longlong *)op1) = in1/in2;
        }
    }
}

NPY_NO_EXPORT void
ULONGLONG_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((ulonglong *)op1) = 0;
        }
        else {
            *((ulonglong *)op1)= in1/in2;
        }
    }
}

NPY_NO_EXPORT void
LONGLONG_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longlong in1 = *(longlong *)ip1;
        const longlong in2 = *(longlong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((longlong *)op1) = 0;
        }
        else {
            /* handle mixed case the way Python does */
            const longlong rem = in1 % in2;
            if ((in1 > 0) == (in2 > 0) || rem == 0) {
                *((longlong *)op1) = rem;
            }
            else {
                *((longlong *)op1) = rem + in2;
            }
        }
    }
}

NPY_NO_EXPORT void
ULONGLONG_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const ulonglong in1 = *(ulonglong *)ip1;
        const ulonglong in2 = *(ulonglong *)ip2;
        if (in2 == 0) {
            npy_set_floatstatus_divbyzero();
            *((longlong *)op1) = 0;
        }
        else {
            *((longlong *)op1) = in1 % in2;
        }
    }
}



/*
 *****************************************************************************
 **                           DATETIME LOOPS                                **
 *****************************************************************************
 */

#line 949

NPY_NO_EXPORT void
DATETIME_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((datetime *)op1) = 1;
    }
}

NPY_NO_EXPORT void
DATETIME_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        *((datetime *)op1) = (datetime)(-(datetime)in1);
    }
}

NPY_NO_EXPORT void
DATETIME_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        *((Bool *)op1) = !in1;
    }
}


#line 982
NPY_NO_EXPORT void
DATETIME_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 982
NPY_NO_EXPORT void
DATETIME_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 982
NPY_NO_EXPORT void
DATETIME_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 982
NPY_NO_EXPORT void
DATETIME_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 982
NPY_NO_EXPORT void
DATETIME_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 982
NPY_NO_EXPORT void
DATETIME_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 982
NPY_NO_EXPORT void
DATETIME_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 982
NPY_NO_EXPORT void
DATETIME_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
DATETIME_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 1007
NPY_NO_EXPORT void
DATETIME_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(datetime) {
            const datetime in2 = *(datetime *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((datetime *)iop1) = io1;
    }
    else {
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((datetime *)op1) = (in1 > in2) ? in1 : in2;
    }
    }
}

#line 1007
NPY_NO_EXPORT void
DATETIME_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(datetime) {
            const datetime in2 = *(datetime *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((datetime *)iop1) = io1;
    }
    else {
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((datetime *)op1) = (in1 < in2) ? in1 : in2;
    }
    }
}


NPY_NO_EXPORT void
DATETIME_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        *((datetime *)op1) = (in1 >= 0) ? in1 : -in1;
    }
}

NPY_NO_EXPORT void
DATETIME_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        *((datetime *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : 0);
    }
}


#line 949

NPY_NO_EXPORT void
TIMEDELTA_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((timedelta *)op1) = 1;
    }
}

NPY_NO_EXPORT void
TIMEDELTA_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        *((timedelta *)op1) = (timedelta)(-(timedelta)in1);
    }
}

NPY_NO_EXPORT void
TIMEDELTA_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        *((Bool *)op1) = !in1;
    }
}


#line 982
NPY_NO_EXPORT void
TIMEDELTA_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 982
NPY_NO_EXPORT void
TIMEDELTA_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 982
NPY_NO_EXPORT void
TIMEDELTA_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 982
NPY_NO_EXPORT void
TIMEDELTA_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 982
NPY_NO_EXPORT void
TIMEDELTA_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 982
NPY_NO_EXPORT void
TIMEDELTA_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 982
NPY_NO_EXPORT void
TIMEDELTA_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 982
NPY_NO_EXPORT void
TIMEDELTA_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
TIMEDELTA_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

#line 1007
NPY_NO_EXPORT void
TIMEDELTA_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(timedelta) {
            const timedelta in2 = *(timedelta *)ip2;
            io1 = (io1 > in2) ? io1 : in2;
        }
        *((timedelta *)iop1) = io1;
    }
    else {
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((timedelta *)op1) = (in1 > in2) ? in1 : in2;
    }
    }
}

#line 1007
NPY_NO_EXPORT void
TIMEDELTA_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(timedelta) {
            const timedelta in2 = *(timedelta *)ip2;
            io1 = (io1 < in2) ? io1 : in2;
        }
        *((timedelta *)iop1) = io1;
    }
    else {
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((timedelta *)op1) = (in1 < in2) ? in1 : in2;
    }
    }
}


NPY_NO_EXPORT void
TIMEDELTA_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        *((timedelta *)op1) = (in1 >= 0) ? in1 : -in1;
    }
}

NPY_NO_EXPORT void
TIMEDELTA_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        *((timedelta *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : 0);
    }
}



/* FIXME: implement the following correctly using the metadata:  data is the
   sequence of ndarrays in the same order as args.
 */
NPY_NO_EXPORT void
DATETIME_Mm_M_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((datetime *)op1) = in1 + in2;
    }
}

NPY_NO_EXPORT void
DATETIME_mM_M_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((datetime *)op1) = in1 + in2;
    }
}

NPY_NO_EXPORT void
TIMEDELTA_mm_m_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((timedelta *)op1) = in1 + in2;
    }
}

NPY_NO_EXPORT void
DATETIME_Mm_M_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((datetime *)op1) = in1 - in2;
    }
}

NPY_NO_EXPORT void
DATETIME_MM_m_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const datetime in1 = *(datetime *)ip1;
        const datetime in2 = *(datetime *)ip2;
        *((timedelta *)op1) = in1 - in2;
    }
}

NPY_NO_EXPORT void
TIMEDELTA_mm_m_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const timedelta in1 = *(timedelta *)ip1;
        const timedelta in2 = *(timedelta *)ip2;
        *((timedelta *)op1) = in1 - in2;
    }
}


/*
 *****************************************************************************
 **                             FLOAT LOOPS                                 **
 *****************************************************************************
 */


#line 1125


#line 1132
NPY_NO_EXPORT void
FLOAT_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            io1 += *(float *)ip2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = in1 + in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
FLOAT_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            io1 -= *(float *)ip2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = in1 - in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
FLOAT_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            io1 *= *(float *)ip2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = in1 * in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
FLOAT_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            io1 /= *(float *)ip2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = in1 / in2;
        }
    }
}


#line 1156
NPY_NO_EXPORT void
FLOAT_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 1156
NPY_NO_EXPORT void
FLOAT_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 1156
NPY_NO_EXPORT void
FLOAT_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 1156
NPY_NO_EXPORT void
FLOAT_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 1156
NPY_NO_EXPORT void
FLOAT_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 1156
NPY_NO_EXPORT void
FLOAT_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 1156
NPY_NO_EXPORT void
FLOAT_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 1156
NPY_NO_EXPORT void
FLOAT_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
FLOAT_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

NPY_NO_EXPORT void
FLOAT_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((Bool *)op1) = !in1;
    }
}

#line 1190
NPY_NO_EXPORT void
FLOAT_isnan(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((Bool *)op1) = npy_isnan(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
FLOAT_isinf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((Bool *)op1) = npy_isinf(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
FLOAT_isfinite(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((Bool *)op1) = npy_isfinite(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
FLOAT_signbit(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((Bool *)op1) = npy_signbit(in1) != 0;
    }
}


NPY_NO_EXPORT void
FLOAT_spacing(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((float *)op1) = npy_spacingf(in1);
    }
}

NPY_NO_EXPORT void
FLOAT_copysign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((float *)op1)= npy_copysignf(in1, in2);
    }
}

NPY_NO_EXPORT void
FLOAT_nextafter(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((float *)op1)= npy_nextafterf(in1, in2);
    }
}

#line 1233
NPY_NO_EXPORT void
FLOAT_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            const float in2 = *(float *)ip2;
            io1 = (io1 >= in2 || npy_isnan(io1)) ? io1 : in2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = (in1 >= in2 || npy_isnan(in1)) ? in1 : in2;
        }
    }
}

#line 1233
NPY_NO_EXPORT void
FLOAT_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            const float in2 = *(float *)ip2;
            io1 = (io1 <= in2 || npy_isnan(io1)) ? io1 : in2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = (in1 <= in2 || npy_isnan(in1)) ? in1 : in2;
        }
    }
}


#line 1258
NPY_NO_EXPORT void
FLOAT_fmax(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            const float in2 = *(float *)ip2;
            io1 = (io1 >= in2 || npy_isnan(in2)) ? io1 : in2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = (in1 >= in2 || npy_isnan(in2)) ? in1 : in2;
        }
    }
}

#line 1258
NPY_NO_EXPORT void
FLOAT_fmin(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(float) {
            const float in2 = *(float *)ip2;
            io1 = (io1 <= in2 || npy_isnan(in2)) ? io1 : in2;
        }
        *((float *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const float in1 = *(float *)ip1;
            const float in2 = *(float *)ip2;
            *((float *)op1) = (in1 <= in2 || npy_isnan(in2)) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
FLOAT_floor_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        *((float *)op1) = npy_floorf(in1/in2);
    }
}

NPY_NO_EXPORT void
FLOAT_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const float in2 = *(float *)ip2;
        const float res = npy_fmodf(in1,in2);
        if (res && ((in2 < 0) != (res < 0))) {
            *((float *)op1) = res + in2;
        }
        else {
            *((float *)op1) = res;
        }
    }
}

NPY_NO_EXPORT void
FLOAT_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((float *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
FLOAT_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((float *)op1) = 1/in1;
    }
}

NPY_NO_EXPORT void
FLOAT_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((float *)op1) = 1;
    }
}

NPY_NO_EXPORT void
FLOAT_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((float *)op1) = in1;
    }
}

NPY_NO_EXPORT void
FLOAT_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        const float tmp = in1 > 0 ? in1 : -in1;
        /* add 0 to clear -0.0 */
        *((float *)op1) = tmp + 0;
    }
}

NPY_NO_EXPORT void
FLOAT_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((float *)op1) = -in1;
    }
}

NPY_NO_EXPORT void
FLOAT_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /* Sign of nan is nan */
    UNARY_LOOP {
        const float in1 = *(float *)ip1;
        *((float *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : (in1 == 0 ? 0 : in1));
    }
}

NPY_NO_EXPORT void
FLOAT_modf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP_TWO_OUT {
        const float in1 = *(float *)ip1;
        *((float *)op1) = npy_modff(in1, (float *)op2);
    }
}

#ifdef HAVE_FREXPF
NPY_NO_EXPORT void
FLOAT_frexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP_TWO_OUT {
        const float in1 = *(float *)ip1;
        *((float *)op1) = frexpf(in1, (int *)op2);
    }
}
#endif

#ifdef HAVE_LDEXPF
NPY_NO_EXPORT void
FLOAT_ldexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const int in2 = *(int *)ip2;
        *((float *)op1) = ldexpf(in1, in2);
    }
}

NPY_NO_EXPORT void
FLOAT_ldexp_long(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*
     * Additional loop to handle long integer inputs (cf. #866, #1633).
     * long != int on many 64-bit platforms, so we need this second loop
     * to handle the default integer type.
     */
    BINARY_LOOP {
        const float in1 = *(float *)ip1;
        const long in2 = *(long *)ip2;
        if (((int)in2) == in2) {
            /* Range OK */
            *((float *)op1) = ldexpf(in1, ((int)in2));
        }
        else {
            /*
             * Outside int range -- also ldexp will overflow in this case,
             * given that exponent has less bits than int.
             */
            if (in2 > 0) {
                *((float *)op1) = ldexpf(in1, NPY_MAX_INT);
            }
            else {
                *((float *)op1) = ldexpf(in1, NPY_MIN_INT);
            }
        }
    }
}
#endif

#define FLOAT_true_divide FLOAT_divide


#line 1125


#line 1132
NPY_NO_EXPORT void
DOUBLE_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            io1 += *(double *)ip2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = in1 + in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
DOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            io1 -= *(double *)ip2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = in1 - in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
DOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            io1 *= *(double *)ip2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = in1 * in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
DOUBLE_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            io1 /= *(double *)ip2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = in1 / in2;
        }
    }
}


#line 1156
NPY_NO_EXPORT void
DOUBLE_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 1156
NPY_NO_EXPORT void
DOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 1156
NPY_NO_EXPORT void
DOUBLE_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 1156
NPY_NO_EXPORT void
DOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 1156
NPY_NO_EXPORT void
DOUBLE_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 1156
NPY_NO_EXPORT void
DOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 1156
NPY_NO_EXPORT void
DOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 1156
NPY_NO_EXPORT void
DOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
DOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

NPY_NO_EXPORT void
DOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((Bool *)op1) = !in1;
    }
}

#line 1190
NPY_NO_EXPORT void
DOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((Bool *)op1) = npy_isnan(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
DOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((Bool *)op1) = npy_isinf(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
DOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((Bool *)op1) = npy_isfinite(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
DOUBLE_signbit(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((Bool *)op1) = npy_signbit(in1) != 0;
    }
}


NPY_NO_EXPORT void
DOUBLE_spacing(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((double *)op1) = npy_spacing(in1);
    }
}

NPY_NO_EXPORT void
DOUBLE_copysign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((double *)op1)= npy_copysign(in1, in2);
    }
}

NPY_NO_EXPORT void
DOUBLE_nextafter(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((double *)op1)= npy_nextafter(in1, in2);
    }
}

#line 1233
NPY_NO_EXPORT void
DOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            const double in2 = *(double *)ip2;
            io1 = (io1 >= in2 || npy_isnan(io1)) ? io1 : in2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = (in1 >= in2 || npy_isnan(in1)) ? in1 : in2;
        }
    }
}

#line 1233
NPY_NO_EXPORT void
DOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            const double in2 = *(double *)ip2;
            io1 = (io1 <= in2 || npy_isnan(io1)) ? io1 : in2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = (in1 <= in2 || npy_isnan(in1)) ? in1 : in2;
        }
    }
}


#line 1258
NPY_NO_EXPORT void
DOUBLE_fmax(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            const double in2 = *(double *)ip2;
            io1 = (io1 >= in2 || npy_isnan(in2)) ? io1 : in2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = (in1 >= in2 || npy_isnan(in2)) ? in1 : in2;
        }
    }
}

#line 1258
NPY_NO_EXPORT void
DOUBLE_fmin(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(double) {
            const double in2 = *(double *)ip2;
            io1 = (io1 <= in2 || npy_isnan(in2)) ? io1 : in2;
        }
        *((double *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const double in1 = *(double *)ip1;
            const double in2 = *(double *)ip2;
            *((double *)op1) = (in1 <= in2 || npy_isnan(in2)) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
DOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        *((double *)op1) = npy_floor(in1/in2);
    }
}

NPY_NO_EXPORT void
DOUBLE_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const double in2 = *(double *)ip2;
        const double res = npy_fmod(in1,in2);
        if (res && ((in2 < 0) != (res < 0))) {
            *((double *)op1) = res + in2;
        }
        else {
            *((double *)op1) = res;
        }
    }
}

NPY_NO_EXPORT void
DOUBLE_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((double *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
DOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((double *)op1) = 1/in1;
    }
}

NPY_NO_EXPORT void
DOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((double *)op1) = 1;
    }
}

NPY_NO_EXPORT void
DOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((double *)op1) = in1;
    }
}

NPY_NO_EXPORT void
DOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        const double tmp = in1 > 0 ? in1 : -in1;
        /* add 0 to clear -0.0 */
        *((double *)op1) = tmp + 0;
    }
}

NPY_NO_EXPORT void
DOUBLE_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((double *)op1) = -in1;
    }
}

NPY_NO_EXPORT void
DOUBLE_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /* Sign of nan is nan */
    UNARY_LOOP {
        const double in1 = *(double *)ip1;
        *((double *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : (in1 == 0 ? 0 : in1));
    }
}

NPY_NO_EXPORT void
DOUBLE_modf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP_TWO_OUT {
        const double in1 = *(double *)ip1;
        *((double *)op1) = npy_modf(in1, (double *)op2);
    }
}

#ifdef HAVE_FREXP
NPY_NO_EXPORT void
DOUBLE_frexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP_TWO_OUT {
        const double in1 = *(double *)ip1;
        *((double *)op1) = frexp(in1, (int *)op2);
    }
}
#endif

#ifdef HAVE_LDEXP
NPY_NO_EXPORT void
DOUBLE_ldexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const int in2 = *(int *)ip2;
        *((double *)op1) = ldexp(in1, in2);
    }
}

NPY_NO_EXPORT void
DOUBLE_ldexp_long(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*
     * Additional loop to handle long integer inputs (cf. #866, #1633).
     * long != int on many 64-bit platforms, so we need this second loop
     * to handle the default integer type.
     */
    BINARY_LOOP {
        const double in1 = *(double *)ip1;
        const long in2 = *(long *)ip2;
        if (((int)in2) == in2) {
            /* Range OK */
            *((double *)op1) = ldexp(in1, ((int)in2));
        }
        else {
            /*
             * Outside int range -- also ldexp will overflow in this case,
             * given that exponent has less bits than int.
             */
            if (in2 > 0) {
                *((double *)op1) = ldexp(in1, NPY_MAX_INT);
            }
            else {
                *((double *)op1) = ldexp(in1, NPY_MIN_INT);
            }
        }
    }
}
#endif

#define DOUBLE_true_divide DOUBLE_divide


#line 1125


#line 1132
NPY_NO_EXPORT void
LONGDOUBLE_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            io1 += *(longdouble *)ip2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = in1 + in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
LONGDOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            io1 -= *(longdouble *)ip2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = in1 - in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
LONGDOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            io1 *= *(longdouble *)ip2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = in1 * in2;
        }
    }
}

#line 1132
NPY_NO_EXPORT void
LONGDOUBLE_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            io1 /= *(longdouble *)ip2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = in1 / in2;
        }
    }
}


#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 == in2;
    }
}

#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 != in2;
    }
}

#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 < in2;
    }
}

#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 <= in2;
    }
}

#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 > in2;
    }
}

#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 >= in2;
    }
}

#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 && in2;
    }
}

#line 1156
NPY_NO_EXPORT void
LONGDOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1) = in1 || in2;
    }
}


NPY_NO_EXPORT void
LONGDOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((Bool *)op1) = !in1;
    }
}

#line 1190
NPY_NO_EXPORT void
LONGDOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((Bool *)op1) = npy_isnan(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
LONGDOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((Bool *)op1) = npy_isinf(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
LONGDOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((Bool *)op1) = npy_isfinite(in1) != 0;
    }
}

#line 1190
NPY_NO_EXPORT void
LONGDOUBLE_signbit(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((Bool *)op1) = npy_signbit(in1) != 0;
    }
}


NPY_NO_EXPORT void
LONGDOUBLE_spacing(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = npy_spacingl(in1);
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_copysign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((longdouble *)op1)= npy_copysignl(in1, in2);
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_nextafter(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((longdouble *)op1)= npy_nextafterl(in1, in2);
    }
}

#line 1233
NPY_NO_EXPORT void
LONGDOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            const longdouble in2 = *(longdouble *)ip2;
            io1 = (io1 >= in2 || npy_isnan(io1)) ? io1 : in2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = (in1 >= in2 || npy_isnan(in1)) ? in1 : in2;
        }
    }
}

#line 1233
NPY_NO_EXPORT void
LONGDOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            const longdouble in2 = *(longdouble *)ip2;
            io1 = (io1 <= in2 || npy_isnan(io1)) ? io1 : in2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = (in1 <= in2 || npy_isnan(in1)) ? in1 : in2;
        }
    }
}


#line 1258
NPY_NO_EXPORT void
LONGDOUBLE_fmax(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            const longdouble in2 = *(longdouble *)ip2;
            io1 = (io1 >= in2 || npy_isnan(in2)) ? io1 : in2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = (in1 >= in2 || npy_isnan(in2)) ? in1 : in2;
        }
    }
}

#line 1258
NPY_NO_EXPORT void
LONGDOUBLE_fmin(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    if (IS_BINARY_REDUCE) {
        BINARY_REDUCE_LOOP(longdouble) {
            const longdouble in2 = *(longdouble *)ip2;
            io1 = (io1 <= in2 || npy_isnan(in2)) ? io1 : in2;
        }
        *((longdouble *)iop1) = io1;
    }
    else {
        BINARY_LOOP {
            const longdouble in1 = *(longdouble *)ip1;
            const longdouble in2 = *(longdouble *)ip2;
            *((longdouble *)op1) = (in1 <= in2 || npy_isnan(in2)) ? in1 : in2;
        }
    }
}


NPY_NO_EXPORT void
LONGDOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        *((longdouble *)op1) = npy_floorl(in1/in2);
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble in2 = *(longdouble *)ip2;
        const longdouble res = npy_fmodl(in1,in2);
        if (res && ((in2 < 0) != (res < 0))) {
            *((longdouble *)op1) = res + in2;
        }
        else {
            *((longdouble *)op1) = res;
        }
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = in1*in1;
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = 1/in1;
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((longdouble *)op1) = 1;
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = in1;
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const longdouble tmp = in1 > 0 ? in1 : -in1;
        /* add 0 to clear -0.0 */
        *((longdouble *)op1) = tmp + 0;
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = -in1;
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /* Sign of nan is nan */
    UNARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = in1 > 0 ? 1 : (in1 < 0 ? -1 : (in1 == 0 ? 0 : in1));
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_modf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP_TWO_OUT {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = npy_modfl(in1, (longdouble *)op2);
    }
}

#ifdef HAVE_FREXPL
NPY_NO_EXPORT void
LONGDOUBLE_frexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP_TWO_OUT {
        const longdouble in1 = *(longdouble *)ip1;
        *((longdouble *)op1) = frexpl(in1, (int *)op2);
    }
}
#endif

#ifdef HAVE_LDEXPL
NPY_NO_EXPORT void
LONGDOUBLE_ldexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const int in2 = *(int *)ip2;
        *((longdouble *)op1) = ldexpl(in1, in2);
    }
}

NPY_NO_EXPORT void
LONGDOUBLE_ldexp_long(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*
     * Additional loop to handle long integer inputs (cf. #866, #1633).
     * long != int on many 64-bit platforms, so we need this second loop
     * to handle the default integer type.
     */
    BINARY_LOOP {
        const longdouble in1 = *(longdouble *)ip1;
        const long in2 = *(long *)ip2;
        if (((int)in2) == in2) {
            /* Range OK */
            *((longdouble *)op1) = ldexpl(in1, ((int)in2));
        }
        else {
            /*
             * Outside int range -- also ldexp will overflow in this case,
             * given that exponent has less bits than int.
             */
            if (in2 > 0) {
                *((longdouble *)op1) = ldexpl(in1, NPY_MAX_INT);
            }
            else {
                *((longdouble *)op1) = ldexpl(in1, NPY_MIN_INT);
            }
        }
    }
}
#endif

#define LONGDOUBLE_true_divide LONGDOUBLE_divide



/*
 *****************************************************************************
 **                          HALF-FLOAT LOOPS                               **
 *****************************************************************************
 */


#line 1448
NPY_NO_EXPORT void
HALF_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        char *iop1 = args[0];
        float io1 = npy_half_to_float(*(npy_half *)iop1);
        BINARY_REDUCE_LOOP_INNER {
            io1 += npy_half_to_float(*(npy_half *)ip2);
        }
        *((npy_half *)iop1) = npy_float_to_half(io1);
    }
    else {
        BINARY_LOOP {
            const float in1 = npy_half_to_float(*(npy_half *)ip1);
            const float in2 = npy_half_to_float(*(npy_half *)ip2);
            *((npy_half *)op1) = npy_float_to_half(in1 + in2);
        }
    }
}

#line 1448
NPY_NO_EXPORT void
HALF_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        char *iop1 = args[0];
        float io1 = npy_half_to_float(*(npy_half *)iop1);
        BINARY_REDUCE_LOOP_INNER {
            io1 -= npy_half_to_float(*(npy_half *)ip2);
        }
        *((npy_half *)iop1) = npy_float_to_half(io1);
    }
    else {
        BINARY_LOOP {
            const float in1 = npy_half_to_float(*(npy_half *)ip1);
            const float in2 = npy_half_to_float(*(npy_half *)ip2);
            *((npy_half *)op1) = npy_float_to_half(in1 - in2);
        }
    }
}

#line 1448
NPY_NO_EXPORT void
HALF_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        char *iop1 = args[0];
        float io1 = npy_half_to_float(*(npy_half *)iop1);
        BINARY_REDUCE_LOOP_INNER {
            io1 *= npy_half_to_float(*(npy_half *)ip2);
        }
        *((npy_half *)iop1) = npy_float_to_half(io1);
    }
    else {
        BINARY_LOOP {
            const float in1 = npy_half_to_float(*(npy_half *)ip1);
            const float in2 = npy_half_to_float(*(npy_half *)ip2);
            *((npy_half *)op1) = npy_float_to_half(in1 * in2);
        }
    }
}

#line 1448
NPY_NO_EXPORT void
HALF_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    if(IS_BINARY_REDUCE) {
        char *iop1 = args[0];
        float io1 = npy_half_to_float(*(npy_half *)iop1);
        BINARY_REDUCE_LOOP_INNER {
            io1 /= npy_half_to_float(*(npy_half *)ip2);
        }
        *((npy_half *)iop1) = npy_float_to_half(io1);
    }
    else {
        BINARY_LOOP {
            const float in1 = npy_half_to_float(*(npy_half *)ip1);
            const float in2 = npy_half_to_float(*(npy_half *)ip2);
            *((npy_half *)op1) = npy_float_to_half(in1 / in2);
        }
    }
}


#define _HALF_LOGICAL_AND(a,b) (!npy_half_iszero(a) && !npy_half_iszero(b))
#define _HALF_LOGICAL_OR(a,b) (!npy_half_iszero(a) || !npy_half_iszero(b))
#line 1476
NPY_NO_EXPORT void
HALF_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = npy_half_eq(in1, in2);
    }
}

#line 1476
NPY_NO_EXPORT void
HALF_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = npy_half_ne(in1, in2);
    }
}

#line 1476
NPY_NO_EXPORT void
HALF_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = npy_half_lt(in1, in2);
    }
}

#line 1476
NPY_NO_EXPORT void
HALF_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = npy_half_le(in1, in2);
    }
}

#line 1476
NPY_NO_EXPORT void
HALF_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = npy_half_gt(in1, in2);
    }
}

#line 1476
NPY_NO_EXPORT void
HALF_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = npy_half_ge(in1, in2);
    }
}

#line 1476
NPY_NO_EXPORT void
HALF_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = _HALF_LOGICAL_AND(in1, in2);
    }
}

#line 1476
NPY_NO_EXPORT void
HALF_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((Bool *)op1) = _HALF_LOGICAL_OR(in1, in2);
    }
}

#undef _HALF_LOGICAL_AND
#undef _HALF_LOGICAL_OR

NPY_NO_EXPORT void
HALF_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const int in1 = !npy_half_iszero(*(npy_half *)ip1);
        const int in2 = !npy_half_iszero(*(npy_half *)ip2);
        *((Bool *)op1)= (in1 && !in2) || (!in1 && in2);
    }
}

NPY_NO_EXPORT void
HALF_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((Bool *)op1) = npy_half_iszero(in1);
    }
}

#line 1512
NPY_NO_EXPORT void
HALF_isnan(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((Bool *)op1) = npy_half_isnan(in1) != 0;
    }
}

#line 1512
NPY_NO_EXPORT void
HALF_isinf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((Bool *)op1) = npy_half_isinf(in1) != 0;
    }
}

#line 1512
NPY_NO_EXPORT void
HALF_isfinite(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((Bool *)op1) = npy_half_isfinite(in1) != 0;
    }
}

#line 1512
NPY_NO_EXPORT void
HALF_signbit(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((Bool *)op1) = npy_half_signbit(in1) != 0;
    }
}


NPY_NO_EXPORT void
HALF_spacing(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((npy_half *)op1) = npy_half_spacing(in1);
    }
}

NPY_NO_EXPORT void
HALF_copysign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((npy_half *)op1)= npy_half_copysign(in1, in2);
    }
}

NPY_NO_EXPORT void
HALF_nextafter(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((npy_half *)op1)= npy_half_nextafter(in1, in2);
    }
}

#line 1555
NPY_NO_EXPORT void
HALF_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((npy_half *)op1) = (npy_half_ge(in1, in2) || npy_half_isnan(in1)) ? in1 : in2;
    }
}

#line 1555
NPY_NO_EXPORT void
HALF_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((npy_half *)op1) = (npy_half_le(in1, in2) || npy_half_isnan(in1)) ? in1 : in2;
    }
}


#line 1571
NPY_NO_EXPORT void
HALF_fmax(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((npy_half *)op1) = (npy_half_ge(in1, in2) || npy_half_isnan(in2)) ? in1 : in2;
    }
}

#line 1571
NPY_NO_EXPORT void
HALF_fmin(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*  */
    BINARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        const npy_half in2 = *(npy_half *)ip2;
        *((npy_half *)op1) = (npy_half_le(in1, in2) || npy_half_isnan(in2)) ? in1 : in2;
    }
}


NPY_NO_EXPORT void
HALF_floor_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        const float in2 = npy_half_to_float(*(npy_half *)ip2);
        *((npy_half *)op1) = npy_float_to_half(npy_floorf(in1/in2));
    }
}

NPY_NO_EXPORT void
HALF_remainder(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        const float in2 = npy_half_to_float(*(npy_half *)ip2);
        const float res = npy_fmodf(in1,in2);
        if (res && ((in2 < 0) != (res < 0))) {
            *((npy_half *)op1) = npy_float_to_half(res + in2);
        }
        else {
            *((npy_half *)op1) = npy_float_to_half(res);
        }
    }
}

NPY_NO_EXPORT void
HALF_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        *((npy_half *)op1) = npy_float_to_half(in1*in1);
    }
}

NPY_NO_EXPORT void
HALF_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        *((npy_half *)op1) = npy_float_to_half(1/in1);
    }
}

NPY_NO_EXPORT void
HALF_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        *((npy_half *)op1) = NPY_HALF_ONE;
    }
}

NPY_NO_EXPORT void
HALF_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((npy_half *)op1) = in1;
    }
}

NPY_NO_EXPORT void
HALF_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((npy_half *)op1) = in1&0x7fffu;
    }
}

NPY_NO_EXPORT void
HALF_negative(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((npy_half *)op1) = in1^0x8000u;
    }
}

NPY_NO_EXPORT void
HALF_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /* Sign of nan is nan */
    UNARY_LOOP {
        const npy_half in1 = *(npy_half *)ip1;
        *((npy_half *)op1) = npy_half_isnan(in1) ? in1 :
                    (((in1&0x7fffu) == 0) ? 0 :
                      (((in1&0x8000u) == 0) ? NPY_HALF_ONE : NPY_HALF_NEGONE));
    }
}

NPY_NO_EXPORT void
HALF_modf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    float temp;

    UNARY_LOOP_TWO_OUT {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        *((npy_half *)op1) = npy_float_to_half(npy_modff(in1, &temp));
        *((npy_half *)op2) = npy_float_to_half(temp);
    }
}

#ifdef HAVE_FREXPF
NPY_NO_EXPORT void
HALF_frexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP_TWO_OUT {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        *((npy_half *)op1) = npy_float_to_half(frexpf(in1, (int *)op2));
    }
}
#endif

#ifdef HAVE_LDEXPF
NPY_NO_EXPORT void
HALF_ldexp(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        const int in2 = *(int *)ip2;
        *((npy_half *)op1) = npy_float_to_half(ldexpf(in1, in2));
    }
}

NPY_NO_EXPORT void
HALF_ldexp_long(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /*
     * Additional loop to handle long integer inputs (cf. #866, #1633).
     * long != int on many 64-bit platforms, so we need this second loop
     * to handle the default integer type.
     */
    BINARY_LOOP {
        const float in1 = npy_half_to_float(*(npy_half *)ip1);
        const long in2 = *(long *)ip2;
        if (((int)in2) == in2) {
            /* Range OK */
            *((npy_half *)op1) = npy_float_to_half(ldexpf(in1, ((int)in2)));
        }
        else {
            /*
             * Outside int range -- also ldexp will overflow in this case,
             * given that exponent has less bits than int.
             */
            if (in2 > 0) {
                *((npy_half *)op1) = npy_float_to_half(ldexpf(in1, NPY_MAX_INT));
            }
            else {
                *((npy_half *)op1) = npy_float_to_half(ldexpf(in1, NPY_MIN_INT));
            }
        }
    }
}
#endif

#define HALF_true_divide HALF_divide


/*
 *****************************************************************************
 **                           COMPLEX LOOPS                                 **
 *****************************************************************************
 */

#define CGE(xr,xi,yr,yi) ((xr > yr && !npy_isnan(xi) && !npy_isnan(yi)) \
                          || (xr == yr && xi >= yi))
#define CLE(xr,xi,yr,yi) ((xr < yr && !npy_isnan(xi) && !npy_isnan(yi)) \
                          || (xr == yr && xi <= yi))
#define CGT(xr,xi,yr,yi) ((xr > yr && !npy_isnan(xi) && !npy_isnan(yi)) \
                          || (xr == yr && xi > yi))
#define CLT(xr,xi,yr,yi) ((xr < yr && !npy_isnan(xi) && !npy_isnan(yi)) \
                          || (xr == yr && xi < yi))
#define CEQ(xr,xi,yr,yi) (xr == yr && xi == yi)
#define CNE(xr,xi,yr,yi) (xr != yr || xi != yi)

#line 1766

#line 1772
NPY_NO_EXPORT void
CFLOAT_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        ((float *)op1)[0] = in1r + in2r;
        ((float *)op1)[1] = in1i + in2i;
    }
}

#line 1772
NPY_NO_EXPORT void
CFLOAT_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        ((float *)op1)[0] = in1r - in2r;
        ((float *)op1)[1] = in1i - in2i;
    }
}


NPY_NO_EXPORT void
CFLOAT_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        ((float *)op1)[0] = in1r*in2r - in1i*in2i;
        ((float *)op1)[1] = in1r*in2i + in1i*in2r;
    }
}

NPY_NO_EXPORT void
CFLOAT_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        const float in2r_abs = npy_fabsf(in2r);
        const float in2i_abs = npy_fabsf(in2i);
        if (in2r_abs >= in2i_abs) {
            if (in2r_abs == 0 && in2i_abs == 0) {
                /* divide by zero should yield a complex inf or nan */
                ((float *)op1)[0] = in1r/in2r_abs;
                ((float *)op1)[1] = in1i/in2i_abs;
            }
            else {
                const float rat = in2i/in2r;
                const float scl = 1.0f/(in2r + in2i*rat);
                ((float *)op1)[0] = (in1r + in1i*rat)*scl;
                ((float *)op1)[1] = (in1i - in1r*rat)*scl;
            }
        }
        else {
            const float rat = in2r/in2i;
            const float scl = 1.0f/(in2i + in2r*rat);
            ((float *)op1)[0] = (in1r*rat + in1i)*scl;
            ((float *)op1)[1] = (in1i*rat - in1r)*scl;
        }
    }
}

NPY_NO_EXPORT void
CFLOAT_floor_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        if (npy_fabsf(in2r) >= npy_fabsf(in2i)) {
            const float rat = in2i/in2r;
            ((float *)op1)[0] = npy_floorf((in1r + in1i*rat)/(in2r + in2i*rat));
            ((float *)op1)[1] = 0;
        }
        else {
            const float rat = in2r/in2i;
            ((float *)op1)[0] = npy_floorf((in1r*rat + in1i)/(in2i + in2r*rat));
            ((float *)op1)[1] = 0;
        }
    }
}

#line 1856
NPY_NO_EXPORT void
CFLOAT_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = CGT(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CFLOAT_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = CGE(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CFLOAT_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = CLT(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CFLOAT_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = CLE(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CFLOAT_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = CEQ(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CFLOAT_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = CNE(in1r,in1i,in2r,in2i);
    }
}


#line 1874
NPY_NO_EXPORT void
CFLOAT_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = (in1r || in1i) && (in2r || in2i);
    }
}

#line 1874
NPY_NO_EXPORT void
CFLOAT_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        *((Bool *)op1) = (in1r || in1i) || (in2r || in2i);
    }
}


NPY_NO_EXPORT void
CFLOAT_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        const Bool tmp1 = (in1r || in1i);
        const Bool tmp2 = (in2r || in2i);
        *((Bool *)op1) = (tmp1 && !tmp2) || (!tmp1 && tmp2);
    }
}

NPY_NO_EXPORT void
CFLOAT_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        *((Bool *)op1) = !(in1r || in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CFLOAT_isnan(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        *((Bool *)op1) = npy_isnan(in1r) || npy_isnan(in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CFLOAT_isinf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        *((Bool *)op1) = npy_isinf(in1r) || npy_isinf(in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CFLOAT_isfinite(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        *((Bool *)op1) = npy_isfinite(in1r) && npy_isfinite(in1i);
    }
}


NPY_NO_EXPORT void
CFLOAT_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        ((float *)op1)[0] = in1r*in1r - in1i*in1i;
        ((float *)op1)[1] = in1r*in1i + in1i*in1r;
    }
}

NPY_NO_EXPORT void
CFLOAT_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        if (npy_fabsf(in1i) <= npy_fabsf(in1r)) {
            const float r = in1i/in1r;
            const float d = in1r + in1i*r;
            ((float *)op1)[0] = 1/d;
            ((float *)op1)[1] = -r/d;
        } else {
            const float r = in1r/in1i;
            const float d = in1r*r + in1i;
            ((float *)op1)[0] = r/d;
            ((float *)op1)[1] = -1/d;
        }
    }
}

NPY_NO_EXPORT void
CFLOAT_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        ((float *)op1)[0] = 1;
        ((float *)op1)[1] = 0;
    }
}

NPY_NO_EXPORT void
CFLOAT_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        ((float *)op1)[0] = in1r;
        ((float *)op1)[1] = -in1i;
    }
}

NPY_NO_EXPORT void
CFLOAT_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        *((float *)op1) = npy_hypotf(in1r, in1i);
    }
}

NPY_NO_EXPORT void
CFLOAT__arg(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        *((float *)op1) = npy_atan2f(in1i, in1r);
    }
}

NPY_NO_EXPORT void
CFLOAT_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /* fixme: sign of nan is currently 0 */
    UNARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        ((float *)op1)[0] = CGT(in1r, in1i, 0.0, 0.0) ?  1 :
                            (CLT(in1r, in1i, 0.0, 0.0) ? -1 :
                            (CEQ(in1r, in1i, 0.0, 0.0) ?  0 : NPY_NANF));
        ((float *)op1)[1] = 0;
    }
}

#line 2015
NPY_NO_EXPORT void
CFLOAT_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        if (CGE(in1r, in1i, in2r, in2i) || npy_isnan(in1r) || npy_isnan(in1i)) {
            ((float *)op1)[0] = in1r;
            ((float *)op1)[1] = in1i;
        }
        else {
            ((float *)op1)[0] = in2r;
            ((float *)op1)[1] = in2i;
        }
    }
}

#line 2015
NPY_NO_EXPORT void
CFLOAT_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        if (CLE(in1r, in1i, in2r, in2i) || npy_isnan(in1r) || npy_isnan(in1i)) {
            ((float *)op1)[0] = in1r;
            ((float *)op1)[1] = in1i;
        }
        else {
            ((float *)op1)[0] = in2r;
            ((float *)op1)[1] = in2i;
        }
    }
}


#line 2039
NPY_NO_EXPORT void
CFLOAT_fmax(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        if (CGE(in1r, in1i, in2r, in2i) || npy_isnan(in2r) || npy_isnan(in2i)) {
            ((float *)op1)[0] = in1r;
            ((float *)op1)[1] = in1i;
        }
        else {
            ((float *)op1)[0] = in2r;
            ((float *)op1)[1] = in2i;
        }
    }
}

#line 2039
NPY_NO_EXPORT void
CFLOAT_fmin(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const float in1r = ((float *)ip1)[0];
        const float in1i = ((float *)ip1)[1];
        const float in2r = ((float *)ip2)[0];
        const float in2i = ((float *)ip2)[1];
        if (CLE(in1r, in1i, in2r, in2i) || npy_isnan(in2r) || npy_isnan(in2i)) {
            ((float *)op1)[0] = in1r;
            ((float *)op1)[1] = in1i;
        }
        else {
            ((float *)op1)[0] = in2r;
            ((float *)op1)[1] = in2i;
        }
    }
}


#define CFLOAT_true_divide CFLOAT_divide


#line 1766

#line 1772
NPY_NO_EXPORT void
CDOUBLE_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        ((double *)op1)[0] = in1r + in2r;
        ((double *)op1)[1] = in1i + in2i;
    }
}

#line 1772
NPY_NO_EXPORT void
CDOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        ((double *)op1)[0] = in1r - in2r;
        ((double *)op1)[1] = in1i - in2i;
    }
}


NPY_NO_EXPORT void
CDOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        ((double *)op1)[0] = in1r*in2r - in1i*in2i;
        ((double *)op1)[1] = in1r*in2i + in1i*in2r;
    }
}

NPY_NO_EXPORT void
CDOUBLE_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        const double in2r_abs = npy_fabs(in2r);
        const double in2i_abs = npy_fabs(in2i);
        if (in2r_abs >= in2i_abs) {
            if (in2r_abs == 0 && in2i_abs == 0) {
                /* divide by zero should yield a complex inf or nan */
                ((double *)op1)[0] = in1r/in2r_abs;
                ((double *)op1)[1] = in1i/in2i_abs;
            }
            else {
                const double rat = in2i/in2r;
                const double scl = 1.0/(in2r + in2i*rat);
                ((double *)op1)[0] = (in1r + in1i*rat)*scl;
                ((double *)op1)[1] = (in1i - in1r*rat)*scl;
            }
        }
        else {
            const double rat = in2r/in2i;
            const double scl = 1.0/(in2i + in2r*rat);
            ((double *)op1)[0] = (in1r*rat + in1i)*scl;
            ((double *)op1)[1] = (in1i*rat - in1r)*scl;
        }
    }
}

NPY_NO_EXPORT void
CDOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        if (npy_fabs(in2r) >= npy_fabs(in2i)) {
            const double rat = in2i/in2r;
            ((double *)op1)[0] = npy_floor((in1r + in1i*rat)/(in2r + in2i*rat));
            ((double *)op1)[1] = 0;
        }
        else {
            const double rat = in2r/in2i;
            ((double *)op1)[0] = npy_floor((in1r*rat + in1i)/(in2i + in2r*rat));
            ((double *)op1)[1] = 0;
        }
    }
}

#line 1856
NPY_NO_EXPORT void
CDOUBLE_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = CGT(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CDOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = CGE(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CDOUBLE_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = CLT(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CDOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = CLE(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CDOUBLE_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = CEQ(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CDOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = CNE(in1r,in1i,in2r,in2i);
    }
}


#line 1874
NPY_NO_EXPORT void
CDOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = (in1r || in1i) && (in2r || in2i);
    }
}

#line 1874
NPY_NO_EXPORT void
CDOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        *((Bool *)op1) = (in1r || in1i) || (in2r || in2i);
    }
}


NPY_NO_EXPORT void
CDOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        const Bool tmp1 = (in1r || in1i);
        const Bool tmp2 = (in2r || in2i);
        *((Bool *)op1) = (tmp1 && !tmp2) || (!tmp1 && tmp2);
    }
}

NPY_NO_EXPORT void
CDOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        *((Bool *)op1) = !(in1r || in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CDOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        *((Bool *)op1) = npy_isnan(in1r) || npy_isnan(in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CDOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        *((Bool *)op1) = npy_isinf(in1r) || npy_isinf(in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CDOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        *((Bool *)op1) = npy_isfinite(in1r) && npy_isfinite(in1i);
    }
}


NPY_NO_EXPORT void
CDOUBLE_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        ((double *)op1)[0] = in1r*in1r - in1i*in1i;
        ((double *)op1)[1] = in1r*in1i + in1i*in1r;
    }
}

NPY_NO_EXPORT void
CDOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        if (npy_fabs(in1i) <= npy_fabs(in1r)) {
            const double r = in1i/in1r;
            const double d = in1r + in1i*r;
            ((double *)op1)[0] = 1/d;
            ((double *)op1)[1] = -r/d;
        } else {
            const double r = in1r/in1i;
            const double d = in1r*r + in1i;
            ((double *)op1)[0] = r/d;
            ((double *)op1)[1] = -1/d;
        }
    }
}

NPY_NO_EXPORT void
CDOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        ((double *)op1)[0] = 1;
        ((double *)op1)[1] = 0;
    }
}

NPY_NO_EXPORT void
CDOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        ((double *)op1)[0] = in1r;
        ((double *)op1)[1] = -in1i;
    }
}

NPY_NO_EXPORT void
CDOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        *((double *)op1) = npy_hypot(in1r, in1i);
    }
}

NPY_NO_EXPORT void
CDOUBLE__arg(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        *((double *)op1) = npy_atan2(in1i, in1r);
    }
}

NPY_NO_EXPORT void
CDOUBLE_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /* fixme: sign of nan is currently 0 */
    UNARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        ((double *)op1)[0] = CGT(in1r, in1i, 0.0, 0.0) ?  1 :
                            (CLT(in1r, in1i, 0.0, 0.0) ? -1 :
                            (CEQ(in1r, in1i, 0.0, 0.0) ?  0 : NPY_NAN));
        ((double *)op1)[1] = 0;
    }
}

#line 2015
NPY_NO_EXPORT void
CDOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        if (CGE(in1r, in1i, in2r, in2i) || npy_isnan(in1r) || npy_isnan(in1i)) {
            ((double *)op1)[0] = in1r;
            ((double *)op1)[1] = in1i;
        }
        else {
            ((double *)op1)[0] = in2r;
            ((double *)op1)[1] = in2i;
        }
    }
}

#line 2015
NPY_NO_EXPORT void
CDOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        if (CLE(in1r, in1i, in2r, in2i) || npy_isnan(in1r) || npy_isnan(in1i)) {
            ((double *)op1)[0] = in1r;
            ((double *)op1)[1] = in1i;
        }
        else {
            ((double *)op1)[0] = in2r;
            ((double *)op1)[1] = in2i;
        }
    }
}


#line 2039
NPY_NO_EXPORT void
CDOUBLE_fmax(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        if (CGE(in1r, in1i, in2r, in2i) || npy_isnan(in2r) || npy_isnan(in2i)) {
            ((double *)op1)[0] = in1r;
            ((double *)op1)[1] = in1i;
        }
        else {
            ((double *)op1)[0] = in2r;
            ((double *)op1)[1] = in2i;
        }
    }
}

#line 2039
NPY_NO_EXPORT void
CDOUBLE_fmin(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const double in1r = ((double *)ip1)[0];
        const double in1i = ((double *)ip1)[1];
        const double in2r = ((double *)ip2)[0];
        const double in2i = ((double *)ip2)[1];
        if (CLE(in1r, in1i, in2r, in2i) || npy_isnan(in2r) || npy_isnan(in2i)) {
            ((double *)op1)[0] = in1r;
            ((double *)op1)[1] = in1i;
        }
        else {
            ((double *)op1)[0] = in2r;
            ((double *)op1)[1] = in2i;
        }
    }
}


#define CDOUBLE_true_divide CDOUBLE_divide


#line 1766

#line 1772
NPY_NO_EXPORT void
CLONGDOUBLE_add(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        ((longdouble *)op1)[0] = in1r + in2r;
        ((longdouble *)op1)[1] = in1i + in2i;
    }
}

#line 1772
NPY_NO_EXPORT void
CLONGDOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        ((longdouble *)op1)[0] = in1r - in2r;
        ((longdouble *)op1)[1] = in1i - in2i;
    }
}


NPY_NO_EXPORT void
CLONGDOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        ((longdouble *)op1)[0] = in1r*in2r - in1i*in2i;
        ((longdouble *)op1)[1] = in1r*in2i + in1i*in2r;
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        const longdouble in2r_abs = npy_fabsl(in2r);
        const longdouble in2i_abs = npy_fabsl(in2i);
        if (in2r_abs >= in2i_abs) {
            if (in2r_abs == 0 && in2i_abs == 0) {
                /* divide by zero should yield a complex inf or nan */
                ((longdouble *)op1)[0] = in1r/in2r_abs;
                ((longdouble *)op1)[1] = in1i/in2i_abs;
            }
            else {
                const longdouble rat = in2i/in2r;
                const longdouble scl = 1.0l/(in2r + in2i*rat);
                ((longdouble *)op1)[0] = (in1r + in1i*rat)*scl;
                ((longdouble *)op1)[1] = (in1i - in1r*rat)*scl;
            }
        }
        else {
            const longdouble rat = in2r/in2i;
            const longdouble scl = 1.0l/(in2i + in2r*rat);
            ((longdouble *)op1)[0] = (in1r*rat + in1i)*scl;
            ((longdouble *)op1)[1] = (in1i*rat - in1r)*scl;
        }
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        if (npy_fabsl(in2r) >= npy_fabsl(in2i)) {
            const longdouble rat = in2i/in2r;
            ((longdouble *)op1)[0] = npy_floorl((in1r + in1i*rat)/(in2r + in2i*rat));
            ((longdouble *)op1)[1] = 0;
        }
        else {
            const longdouble rat = in2r/in2i;
            ((longdouble *)op1)[0] = npy_floorl((in1r*rat + in1i)/(in2i + in2r*rat));
            ((longdouble *)op1)[1] = 0;
        }
    }
}

#line 1856
NPY_NO_EXPORT void
CLONGDOUBLE_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = CGT(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CLONGDOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = CGE(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CLONGDOUBLE_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = CLT(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CLONGDOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = CLE(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CLONGDOUBLE_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = CEQ(in1r,in1i,in2r,in2i);
    }
}

#line 1856
NPY_NO_EXPORT void
CLONGDOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = CNE(in1r,in1i,in2r,in2i);
    }
}


#line 1874
NPY_NO_EXPORT void
CLONGDOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = (in1r || in1i) && (in2r || in2i);
    }
}

#line 1874
NPY_NO_EXPORT void
CLONGDOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        *((Bool *)op1) = (in1r || in1i) || (in2r || in2i);
    }
}


NPY_NO_EXPORT void
CLONGDOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        const Bool tmp1 = (in1r || in1i);
        const Bool tmp2 = (in2r || in2i);
        *((Bool *)op1) = (tmp1 && !tmp2) || (!tmp1 && tmp2);
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        *((Bool *)op1) = !(in1r || in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CLONGDOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        *((Bool *)op1) = npy_isnan(in1r) || npy_isnan(in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CLONGDOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        *((Bool *)op1) = npy_isinf(in1r) || npy_isinf(in1i);
    }
}

#line 1916
NPY_NO_EXPORT void
CLONGDOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        *((Bool *)op1) = npy_isfinite(in1r) && npy_isfinite(in1i);
    }
}


NPY_NO_EXPORT void
CLONGDOUBLE_square(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        ((longdouble *)op1)[0] = in1r*in1r - in1i*in1i;
        ((longdouble *)op1)[1] = in1r*in1i + in1i*in1r;
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        if (npy_fabsl(in1i) <= npy_fabsl(in1r)) {
            const longdouble r = in1i/in1r;
            const longdouble d = in1r + in1i*r;
            ((longdouble *)op1)[0] = 1/d;
            ((longdouble *)op1)[1] = -r/d;
        } else {
            const longdouble r = in1r/in1i;
            const longdouble d = in1r*r + in1i;
            ((longdouble *)op1)[0] = r/d;
            ((longdouble *)op1)[1] = -1/d;
        }
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(data))
{
    OUTPUT_LOOP {
        ((longdouble *)op1)[0] = 1;
        ((longdouble *)op1)[1] = 0;
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        ((longdouble *)op1)[0] = in1r;
        ((longdouble *)op1)[1] = -in1i;
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        *((longdouble *)op1) = npy_hypotl(in1r, in1i);
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE__arg(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        *((longdouble *)op1) = npy_atan2l(in1i, in1r);
    }
}

NPY_NO_EXPORT void
CLONGDOUBLE_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    /* fixme: sign of nan is currently 0 */
    UNARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        ((longdouble *)op1)[0] = CGT(in1r, in1i, 0.0, 0.0) ?  1 :
                            (CLT(in1r, in1i, 0.0, 0.0) ? -1 :
                            (CEQ(in1r, in1i, 0.0, 0.0) ?  0 : NPY_NANL));
        ((longdouble *)op1)[1] = 0;
    }
}

#line 2015
NPY_NO_EXPORT void
CLONGDOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        if (CGE(in1r, in1i, in2r, in2i) || npy_isnan(in1r) || npy_isnan(in1i)) {
            ((longdouble *)op1)[0] = in1r;
            ((longdouble *)op1)[1] = in1i;
        }
        else {
            ((longdouble *)op1)[0] = in2r;
            ((longdouble *)op1)[1] = in2i;
        }
    }
}

#line 2015
NPY_NO_EXPORT void
CLONGDOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        if (CLE(in1r, in1i, in2r, in2i) || npy_isnan(in1r) || npy_isnan(in1i)) {
            ((longdouble *)op1)[0] = in1r;
            ((longdouble *)op1)[1] = in1i;
        }
        else {
            ((longdouble *)op1)[0] = in2r;
            ((longdouble *)op1)[1] = in2i;
        }
    }
}


#line 2039
NPY_NO_EXPORT void
CLONGDOUBLE_fmax(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        if (CGE(in1r, in1i, in2r, in2i) || npy_isnan(in2r) || npy_isnan(in2i)) {
            ((longdouble *)op1)[0] = in1r;
            ((longdouble *)op1)[1] = in1i;
        }
        else {
            ((longdouble *)op1)[0] = in2r;
            ((longdouble *)op1)[1] = in2i;
        }
    }
}

#line 2039
NPY_NO_EXPORT void
CLONGDOUBLE_fmin(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    BINARY_LOOP {
        const longdouble in1r = ((longdouble *)ip1)[0];
        const longdouble in1i = ((longdouble *)ip1)[1];
        const longdouble in2r = ((longdouble *)ip2)[0];
        const longdouble in2i = ((longdouble *)ip2)[1];
        if (CLE(in1r, in1i, in2r, in2i) || npy_isnan(in2r) || npy_isnan(in2i)) {
            ((longdouble *)op1)[0] = in1r;
            ((longdouble *)op1)[1] = in1i;
        }
        else {
            ((longdouble *)op1)[0] = in2r;
            ((longdouble *)op1)[1] = in2i;
        }
    }
}


#define CLONGDOUBLE_true_divide CLONGDOUBLE_divide



#undef CGE
#undef CLE
#undef CGT
#undef CLT
#undef CEQ
#undef CNE

/*
 *****************************************************************************
 **                            OBJECT LOOPS                                 **
 *****************************************************************************
 */

#line 2080
NPY_NO_EXPORT void
OBJECT_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        int ret = PyObject_RichCompareBool(
                            in1 ? in1 : Py_None,
                            in2 ? in2 : Py_None, Py_EQ);
        if (ret == -1) {
            return;
        }
        *((Bool *)op1) = (Bool)ret;
    }
}

#line 2080
NPY_NO_EXPORT void
OBJECT_not_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        int ret = PyObject_RichCompareBool(
                            in1 ? in1 : Py_None,
                            in2 ? in2 : Py_None, Py_NE);
        if (ret == -1) {
            return;
        }
        *((Bool *)op1) = (Bool)ret;
    }
}

#line 2080
NPY_NO_EXPORT void
OBJECT_greater(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        int ret = PyObject_RichCompareBool(
                            in1 ? in1 : Py_None,
                            in2 ? in2 : Py_None, Py_GT);
        if (ret == -1) {
            return;
        }
        *((Bool *)op1) = (Bool)ret;
    }
}

#line 2080
NPY_NO_EXPORT void
OBJECT_greater_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        int ret = PyObject_RichCompareBool(
                            in1 ? in1 : Py_None,
                            in2 ? in2 : Py_None, Py_GE);
        if (ret == -1) {
            return;
        }
        *((Bool *)op1) = (Bool)ret;
    }
}

#line 2080
NPY_NO_EXPORT void
OBJECT_less(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        int ret = PyObject_RichCompareBool(
                            in1 ? in1 : Py_None,
                            in2 ? in2 : Py_None, Py_LT);
        if (ret == -1) {
            return;
        }
        *((Bool *)op1) = (Bool)ret;
    }
}

#line 2080
NPY_NO_EXPORT void
OBJECT_less_equal(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func)) {
    BINARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject *in2 = *(PyObject **)ip2;
        int ret = PyObject_RichCompareBool(
                            in1 ? in1 : Py_None,
                            in2 ? in2 : Py_None, Py_LE);
        if (ret == -1) {
            return;
        }
        *((Bool *)op1) = (Bool)ret;
    }
}


NPY_NO_EXPORT void
OBJECT_sign(char **args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
#if defined(NPY_PY3K)
    PyObject *zero = PyLong_FromLong(0);
    UNARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject **out = (PyObject **)op1;
        int v;
        PyObject *ret;
        PyObject_Cmp(in1 ? in1 : Py_None, zero, &v);
        ret = PyLong_FromLong(v);
        if (PyErr_Occurred()) {
            return;
        }
        Py_XDECREF(*out);
        *out = ret;
    }
    Py_DECREF(zero);
#else
    PyObject *zero = PyInt_FromLong(0);
    UNARY_LOOP {
        PyObject *in1 = *(PyObject **)ip1;
        PyObject **out = (PyObject **)op1;
        PyObject *ret = PyInt_FromLong(
                            PyObject_Compare(in1 ? in1 : Py_None, zero));
        if (PyErr_Occurred()) {
            return;
        }
        Py_XDECREF(*out);
        *out = ret;
    }
    Py_DECREF(zero);
#endif
}

/*
 *****************************************************************************
 **                              END LOOPS                                  **
 *****************************************************************************
 */

